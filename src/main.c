/*
 * Copyright (c) 2012-2014 Wind River Systems, Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
#include <zephyr/types.h>
#include <stddef.h>
#include <string.h>
#include <errno.h>
#include <zephyr.h>
#include <device.h>
#include <drivers/gpio.h>
#include <sys/printk.h>
#include <sys/reboot.h>

#include <bluetooth/bluetooth.h>
#include <bluetooth/hci.h>
#include <bluetooth/conn.h>
#include <bluetooth/uuid.h>
#include <bluetooth/gatt.h>
#include <settings/settings.h>
#include <drivers/sensor.h>

#include <custom_service.h>
#include <rssi.h>

#define DEVICE_NAME CONFIG_BT_DEVICE_NAME
#define DEVICE_NAME_LEN (sizeof(DEVICE_NAME) - 1)

#define GPIO_PORT	"GPIO_0"

#define	BUTTON1_PIN	13
#define LED1_PIN	17

void reset_counter_handler(struct k_timer *dummy);
void reset_button_work_handler(struct k_work *work) ;
static void start_sensor_reading();

static struct gpio_callback reset_button_cb;
static struct k_work reset_button_work;
const struct device *my_gpio_port;
struct k_timer reset_counter;

const struct device *dht11;

static bool paired = false;
static bool button_press = false;
static bool connected_val = false;

struct bt_conn *default_conn;

// RSSI samplimg
int8_t sampling = 0;
struct k_work_delayable rssi_timer_work;

//Sensor reading work
struct k_work_delayable sensor_read_work;

static const struct bt_data ad[] = {
		BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),
		BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN),
};

// passkey is generated by the stack and provided in callback for display to the user
static void pairing_passkey_display(struct bt_conn *conn, unsigned int passkey)
{
	char addr[BT_ADDR_LE_STR_LEN];
	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
	printk("Passkey for %s: %06u\n", addr, passkey);
}

static void auth_confirm(struct bt_conn *conn, unsigned int passkey)
{
	default_conn = conn;
	char addr[BT_ADDR_LE_STR_LEN];
	char passkey_str[7];
	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
	snprintk(passkey_str, 7, "%06u", passkey);
	printk("\nConfirm passkey for %s: %s\n\n", addr, passkey_str);
	printk("Automatic confirm passkey\n"); // I will add RSSI check for future developments
	int rssi = get_rssi();
	if(rssi <-60)
	{
		printk("Central is not close to the peripheral\n");
		bt_conn_auth_cancel(default_conn);
		bt_conn_disconnect(default_conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
		// default_conn = NULL;
	}
	else
	{
		if(paired == false)
		{
			printk("Peripheral is close to Central Device.\n");
			bt_conn_auth_passkey_confirm(default_conn);
			paired = true;
			// start_sensor_reading();
			k_work_cancel_delayable(&rssi_timer_work); // Connection established. Cancel the RSSI reading. 
		}
	}
}

static void pairing_cancel(struct bt_conn *conn)
{
	printk("Pairing cancelled\n");
	paired = false;
}

// will result in Numeric Comparison being used
static struct bt_conn_auth_cb pairing_cb_display = {
		.passkey_display = pairing_passkey_display,
		.passkey_confirm = auth_confirm,
		.cancel = pairing_cancel,
};

 
static void rssi_polling(struct k_work *work)
{
	if(default_conn != NULL){
		read_rssi(default_conn);
		// and again in a second....
		if (sampling == 1) {
		k_work_schedule(&rssi_timer_work, K_SECONDS(1));
		}
	}
}

static void start_sampling_rssi()
{
	printk("starting RSSI sampling\n");
	sampling = 1;
    k_work_init_delayable(&rssi_timer_work, rssi_polling);
	k_work_schedule(&rssi_timer_work, K_SECONDS(1));
}

static void connected(struct bt_conn *conn, uint8_t err)
{
	if (err)
	{
		printk("Not Connected : %d", err);
		connected_val = false;
	}
	else
	{
		printk("Connected\n");
		connected_val = true;
		start_sensor_reading();
		default_conn = bt_conn_ref(conn);
		int rc = bt_conn_set_security(default_conn, BT_SECURITY_L4);
		printk("requested security level 4 [%d]\n",rc);
		
		if(paired == false)
		{
			start_sampling_rssi();
		}
	}
}

static void disconnected(struct bt_conn *conn, uint8_t reason)
{
	
	if (default_conn)
	{
		printk("Disconnected\n");
		bt_conn_unref(default_conn);
		default_conn = NULL;
    	sampling = 0;
		connected_val = false;
	}
}

static void security_level_changed(struct bt_conn *conn, bt_security_t level, enum bt_security_err err)
{
	printk("security_level_changed to %d\n", level);
}

static struct bt_conn_cb conn_callbacks = {
		.connected = connected,
		.disconnected = disconnected,
		.security_changed = security_level_changed,
};

static void bt_ready(int err)
{
	if (err)
	{
		return;
	}

	custom_service_init();

	if (IS_ENABLED(CONFIG_SETTINGS))
	{
		settings_load();
	}

	err = bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), NULL, 0);
	if (err)
	{
		return;
	}
}

void clear_all_bonds()
{
	/** Clear pairing information.
  *
  * @param id    Local identity (mostly just BT_ID_DEFAULT).
  * @param addr  Remote address, NULL or BT_ADDR_LE_ANY to clear all remote
  *              devices.
  *
  * @return 0 on success or negative error value on failure.
  */
	printk("clearing all bonds\n");
	paired = false;
	int rc = bt_unpair(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
	printk("done [%d]\n", rc);
}

void button1_pressed(const struct device *port,
					struct gpio_callback *cb,
					gpio_port_pins_t pins)
{
	int ret;
	if(button_press == false)
	{
		printk("Button1 work is pressed\n");
		button_press = true;
		k_work_init(&reset_button_work, reset_button_work_handler);
		ret = k_work_submit(&reset_button_work);
		if(ret == 0)
		{
			printk("Button1 work is already in queue\n");
		}
	}	
}

void reset_button_work_handler(struct k_work *work) 
{
	k_timer_start(&reset_counter, K_SECONDS(6), K_NO_WAIT);
	k_work_cancel(&reset_button_work);
}

void reset_counter_handler(struct k_timer *dummy)
{
	printk("Timer expiry function worked\n");
	int val = gpio_pin_get(my_gpio_port,BUTTON1_PIN);
	if( val == 0){
		clear_all_bonds();	
	}  
	button_press = false; 
	
}

void init_timer(){
	k_timer_init(&reset_counter, reset_counter_handler, NULL);
}

void configure_gpios()
{
	int ret;

	my_gpio_port = device_get_binding(GPIO_PORT);

	gpio_pin_configure(my_gpio_port,BUTTON1_PIN , GPIO_INPUT | GPIO_PULL_UP);
	gpio_pin_configure(my_gpio_port, LED1_PIN , GPIO_OUTPUT | GPIO_OUTPUT_ACTIVE);

	gpio_init_callback(&reset_button_cb, button1_pressed, BIT(BUTTON1_PIN));
	gpio_add_callback(my_gpio_port, &reset_button_cb);

	gpio_pin_interrupt_configure(my_gpio_port, BUTTON1_PIN, GPIO_INT_EDGE_TO_INACTIVE);
}

int init_sensor()
{
	const char *const label = DT_LABEL(DT_INST(0, aosong_dht));
	dht11 = device_get_binding(label);

	if (!dht11) {
		printk("Failed to find sensor %s\n", label);
		return 0xFF;
	}
	return 0x00;
}

static void read_sensor()
{
	if(connected_val)
	{
		int rc = sensor_sample_fetch(dht11);

		if (rc != 0) {
			printk("Sensor fetch failed: %d\n", rc);
		}

		struct sensor_value temperature;
		struct sensor_value humidity;

		rc = sensor_channel_get(dht11, SENSOR_CHAN_AMBIENT_TEMP, &temperature);
		if (rc == 0) 
		{
			rc = sensor_channel_get(dht11, SENSOR_CHAN_HUMIDITY,&humidity);
		}
		if (rc != 0) 
		{
			printk("get failed: %d\n", rc);
		}

		T_vals[0]= sensor_value_to_double(&temperature);
		H_vals[0] = sensor_value_to_double(&humidity);
		printk("%.1f Cel ; %.1f %%RH\n",T_vals[0],
										H_vals[0]);

		bt_gatt_notify(NULL, &th_svc.attrs[1], T_vals, sizeof(T_vals));
		bt_gatt_notify(NULL, &th_svc.attrs[3], H_vals, sizeof(H_vals));

		k_work_schedule(&sensor_read_work, K_SECONDS(5)); // Next reading after 5 seconds later
	}
	else
	{
		k_work_cancel_delayable(&sensor_read_work);
	}

}

static void start_sensor_reading(){
	k_work_init_delayable(&sensor_read_work, read_sensor); // Start to sensor reading. Setup the continous work
	k_work_schedule(&sensor_read_work, K_NO_WAIT);
}

void main(void)
{
	
	int err;

	printk("Starting....\n");
	k_sleep(K_SECONDS(1));

	configure_gpios();
	init_timer();

	if(init_sensor() == 0xFF){
		printk("Sensor Fail\n");
		return;
	}

	err = bt_enable(bt_ready);
	if (err)
	{
		return;
	}

	// clear_all_bonds();

	bt_conn_cb_register(&conn_callbacks);

	bt_conn_auth_cb_register(&pairing_cb_display);
}